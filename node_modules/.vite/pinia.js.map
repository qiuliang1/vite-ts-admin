{
  "version": 3,
  "sources": ["../pinia/dist/pinia.esm-bundler.js"],
  "sourcesContent": ["/*!\n  * pinia v2.0.0-rc.10\n  * (c) 2021 Eduardo San Martin Morote\n  * @license MIT\n  */\nimport { getCurrentInstance, inject, toRaw, watch, unref, markRaw, effectScope, ref, isVue2, isRef, isReactive, set, onUnmounted, reactive, toRef, del, computed, toRefs } from 'vue-demi';\nimport { setupDevtoolsPlugin } from '@vue/devtools-api';\n\n/**\r\n * setActivePinia must be called to handle SSR at the top of functions like\r\n * `fetch`, `setup`, `serverPrefetch` and others\r\n */\r\nlet activePinia;\r\n/**\r\n * Sets or unsets the active pinia. Used in SSR and internally when calling\r\n * actions and getters\r\n *\r\n * @param pinia - Pinia instance\r\n */\r\nconst setActivePinia = (pinia) => (activePinia = pinia);\r\n/**\r\n * Get the currently active pinia if there is any.\r\n */\r\nconst getActivePinia = () => (getCurrentInstance() && inject(piniaSymbol)) || activePinia;\r\nconst piniaSymbol = ((process.env.NODE_ENV !== 'production') ? Symbol('pinia') : /* istanbul ignore next */ Symbol());\n\nfunction isPlainObject(\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\no) {\r\n    return (o &&\r\n        typeof o === 'object' &&\r\n        Object.prototype.toString.call(o) === '[object Object]' &&\r\n        typeof o.toJSON !== 'function');\r\n}\r\n// type DeepReadonly<T> = { readonly [P in keyof T]: DeepReadonly<T[P]> }\r\n// TODO: can we change these to numbers?\r\n/**\r\n * Possible types for SubscriptionCallback\r\n */\r\nvar MutationType;\r\n(function (MutationType) {\r\n    /**\r\n     * Direct mutation of the state:\r\n     *\r\n     * - `store.name = 'new name'`\r\n     * - `store.$state.name = 'new name'`\r\n     * - `store.list.push('new item')`\r\n     */\r\n    MutationType[\"direct\"] = \"direct\";\r\n    /**\r\n     * Mutated the state with `$patch` and an object\r\n     *\r\n     * - `store.$patch({ name: 'newName' })`\r\n     */\r\n    MutationType[\"patchObject\"] = \"patch object\";\r\n    /**\r\n     * Mutated the state with `$patch` and a function\r\n     *\r\n     * - `store.$patch(state => state.name = 'newName')`\r\n     */\r\n    MutationType[\"patchFunction\"] = \"patch function\";\r\n    // maybe reset? for $state = {} and $reset\r\n})(MutationType || (MutationType = {}));\n\nconst IS_CLIENT = typeof window !== 'undefined';\n\n/*\r\n * FileSaver.js A saveAs() FileSaver implementation.\r\n *\r\n * Originally by Eli Grey, adapted as an ESM module by Eduardo San Martin\r\n * Morote.\r\n *\r\n * License : MIT\r\n */\r\n// The one and only way of getting global scope in all environments\r\n// https://stackoverflow.com/q/3277182/1008999\r\nconst _global = /*#__PURE__*/ (() => typeof window === 'object' && window.window === window\r\n    ? window\r\n    : typeof self === 'object' && self.self === self\r\n        ? self\r\n        : typeof global === 'object' && global.global === global\r\n            ? global\r\n            : typeof globalThis === 'object'\r\n                ? globalThis\r\n                : { HTMLElement: null })();\r\nfunction bom(blob, { autoBom = false } = {}) {\r\n    // prepend BOM for UTF-8 XML and text/* types (including HTML)\r\n    // note: your browser will automatically convert UTF-16 U+FEFF to EF BB BF\r\n    if (autoBom &&\r\n        /^\\s*(?:text\\/\\S*|application\\/xml|\\S*\\/\\S*\\+xml)\\s*;.*charset\\s*=\\s*utf-8/i.test(blob.type)) {\r\n        return new Blob([String.fromCharCode(0xfeff), blob], { type: blob.type });\r\n    }\r\n    return blob;\r\n}\r\nfunction download(url, name, opts) {\r\n    const xhr = new XMLHttpRequest();\r\n    xhr.open('GET', url);\r\n    xhr.responseType = 'blob';\r\n    xhr.onload = function () {\r\n        saveAs(xhr.response, name, opts);\r\n    };\r\n    xhr.onerror = function () {\r\n        console.error('could not download file');\r\n    };\r\n    xhr.send();\r\n}\r\nfunction corsEnabled(url) {\r\n    const xhr = new XMLHttpRequest();\r\n    // use sync to avoid popup blocker\r\n    xhr.open('HEAD', url, false);\r\n    try {\r\n        xhr.send();\r\n    }\r\n    catch (e) { }\r\n    return xhr.status >= 200 && xhr.status <= 299;\r\n}\r\n// `a.click()` doesn't work for all browsers (#465)\r\nfunction click(node) {\r\n    try {\r\n        node.dispatchEvent(new MouseEvent('click'));\r\n    }\r\n    catch (e) {\r\n        const evt = document.createEvent('MouseEvents');\r\n        evt.initMouseEvent('click', true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null);\r\n        node.dispatchEvent(evt);\r\n    }\r\n}\r\nconst _navigator = \r\n typeof navigator === 'object' ? navigator : { userAgent: '' };\r\n// Detect WebView inside a native macOS app by ruling out all browsers\r\n// We just need to check for 'Safari' because all other browsers (besides Firefox) include that too\r\n// https://www.whatismybrowser.com/guides/the-latest-user-agent/macos\r\nconst isMacOSWebView = /*#__PURE__*/ (() => /Macintosh/.test(_navigator.userAgent) &&\r\n    /AppleWebKit/.test(_navigator.userAgent) &&\r\n    !/Safari/.test(_navigator.userAgent))();\r\nconst saveAs = !IS_CLIENT\r\n    ? () => { } // noop\r\n    : // Use download attribute first if possible (#193 Lumia mobile) unless this is a macOS WebView\r\n        'download' in HTMLAnchorElement.prototype && !isMacOSWebView\r\n            ? downloadSaveAs\r\n            : // Use msSaveOrOpenBlob as a second approach\r\n                'msSaveOrOpenBlob' in _navigator\r\n                    ? msSaveAs\r\n                    : // Fallback to using FileReader and a popup\r\n                        fileSaverSaveAs;\r\nfunction downloadSaveAs(blob, name = 'download', opts) {\r\n    const a = document.createElement('a');\r\n    a.download = name;\r\n    a.rel = 'noopener'; // tabnabbing\r\n    // TODO: detect chrome extensions & packaged apps\r\n    // a.target = '_blank'\r\n    if (typeof blob === 'string') {\r\n        // Support regular links\r\n        a.href = blob;\r\n        if (a.origin !== location.origin) {\r\n            if (corsEnabled(a.href)) {\r\n                download(blob, name, opts);\r\n            }\r\n            else {\r\n                a.target = '_blank';\r\n                click(a);\r\n            }\r\n        }\r\n        else {\r\n            click(a);\r\n        }\r\n    }\r\n    else {\r\n        // Support blobs\r\n        a.href = URL.createObjectURL(blob);\r\n        setTimeout(function () {\r\n            URL.revokeObjectURL(a.href);\r\n        }, 4e4); // 40s\r\n        setTimeout(function () {\r\n            click(a);\r\n        }, 0);\r\n    }\r\n}\r\nfunction msSaveAs(blob, name = 'download', opts) {\r\n    if (typeof blob === 'string') {\r\n        if (corsEnabled(blob)) {\r\n            download(blob, name, opts);\r\n        }\r\n        else {\r\n            const a = document.createElement('a');\r\n            a.href = blob;\r\n            a.target = '_blank';\r\n            setTimeout(function () {\r\n                click(a);\r\n            });\r\n        }\r\n    }\r\n    else {\r\n        // @ts-ignore: works on windows\r\n        navigator.msSaveOrOpenBlob(bom(blob, opts), name);\r\n    }\r\n}\r\nfunction fileSaverSaveAs(blob, name, opts, popup) {\r\n    // Open a popup immediately do go around popup blocker\r\n    // Mostly only available on user interaction and the fileReader is async so...\r\n    popup = popup || open('', '_blank');\r\n    if (popup) {\r\n        popup.document.title = popup.document.body.innerText = 'downloading...';\r\n    }\r\n    if (typeof blob === 'string')\r\n        return download(blob, name, opts);\r\n    const force = blob.type === 'application/octet-stream';\r\n    const isSafari = /constructor/i.test(String(_global.HTMLElement)) || 'safari' in _global;\r\n    const isChromeIOS = /CriOS\\/[\\d]+/.test(navigator.userAgent);\r\n    if ((isChromeIOS || (force && isSafari) || isMacOSWebView) &&\r\n        typeof FileReader !== 'undefined') {\r\n        // Safari doesn't allow downloading of blob URLs\r\n        const reader = new FileReader();\r\n        reader.onloadend = function () {\r\n            let url = reader.result;\r\n            if (typeof url !== 'string') {\r\n                popup = null;\r\n                throw new Error('Wrong reader.result type');\r\n            }\r\n            url = isChromeIOS\r\n                ? url\r\n                : url.replace(/^data:[^;]*;/, 'data:attachment/file;');\r\n            if (popup) {\r\n                popup.location.href = url;\r\n            }\r\n            else {\r\n                location.assign(url);\r\n            }\r\n            popup = null; // reverse-tabnabbing #460\r\n        };\r\n        reader.readAsDataURL(blob);\r\n    }\r\n    else {\r\n        const url = URL.createObjectURL(blob);\r\n        if (popup)\r\n            popup.location.assign(url);\r\n        else\r\n            location.href = url;\r\n        popup = null; // reverse-tabnabbing #460\r\n        setTimeout(function () {\r\n            URL.revokeObjectURL(url);\r\n        }, 4e4); // 40s\r\n    }\r\n}\n\n/**\r\n * Shows a toast or console.log\r\n *\r\n * @param message - message to log\r\n * @param type - different color of the tooltip\r\n */\r\nfunction toastMessage(message, type) {\r\n    const piniaMessage = '\uD83C\uDF4D ' + message;\r\n    if (typeof __VUE_DEVTOOLS_TOAST__ === 'function') {\r\n        __VUE_DEVTOOLS_TOAST__(piniaMessage, type);\r\n    }\r\n    else if (type === 'error') {\r\n        console.error(piniaMessage);\r\n    }\r\n    else if (type === 'warn') {\r\n        console.warn(piniaMessage);\r\n    }\r\n    else {\r\n        console.log(piniaMessage);\r\n    }\r\n}\r\nfunction isPinia(o) {\r\n    return '_a' in o && 'install' in o;\r\n}\n\nfunction checkClipboardAccess() {\r\n    if (!('clipboard' in navigator)) {\r\n        toastMessage(`Your browser doesn't support the Clipboard API`, 'error');\r\n        return true;\r\n    }\r\n}\r\nfunction checkNotFocusedError(error) {\r\n    if (error instanceof Error &&\r\n        error.message.toLowerCase().includes('document is not focused')) {\r\n        toastMessage('You need to activate the \"Emulate a focused page\" setting in the \"Rendering\" panel of devtools.', 'warn');\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\nasync function actionGlobalCopyState(pinia) {\r\n    if (checkClipboardAccess())\r\n        return;\r\n    try {\r\n        await navigator.clipboard.writeText(JSON.stringify(pinia.state.value));\r\n        toastMessage('Global state copied to clipboard.');\r\n    }\r\n    catch (error) {\r\n        if (checkNotFocusedError(error))\r\n            return;\r\n        toastMessage(`Failed to serialize the state. Check the console for more details.`, 'error');\r\n        console.error(error);\r\n    }\r\n}\r\nasync function actionGlobalPasteState(pinia) {\r\n    if (checkClipboardAccess())\r\n        return;\r\n    try {\r\n        pinia.state.value = JSON.parse(await navigator.clipboard.readText());\r\n        toastMessage('Global state pasted from clipboard.');\r\n    }\r\n    catch (error) {\r\n        if (checkNotFocusedError(error))\r\n            return;\r\n        toastMessage(`Failed to deserialize the state from clipboard. Check the console for more details.`, 'error');\r\n        console.error(error);\r\n    }\r\n}\r\nasync function actionGlobalSaveState(pinia) {\r\n    try {\r\n        saveAs(new Blob([JSON.stringify(pinia.state.value)], {\r\n            type: 'text/plain;charset=utf-8',\r\n        }), 'pinia-state.json');\r\n    }\r\n    catch (error) {\r\n        toastMessage(`Failed to export the state as JSON. Check the console for more details.`, 'error');\r\n        console.error(error);\r\n    }\r\n}\r\nlet fileInput;\r\nfunction getFileOpener() {\r\n    if (!fileInput) {\r\n        fileInput = document.createElement('input');\r\n        fileInput.type = 'file';\r\n        fileInput.accept = '.json';\r\n    }\r\n    function openFile() {\r\n        return new Promise((resolve, reject) => {\r\n            fileInput.onchange = async () => {\r\n                const files = fileInput.files;\r\n                if (!files)\r\n                    return resolve(null);\r\n                const file = files.item(0);\r\n                if (!file)\r\n                    return resolve(null);\r\n                return resolve({ text: await file.text(), file });\r\n            };\r\n            // @ts-ignore: TODO: changed from 4.3 to 4.4\r\n            fileInput.oncancel = () => resolve(null);\r\n            fileInput.onerror = reject;\r\n            fileInput.click();\r\n        });\r\n    }\r\n    return openFile;\r\n}\r\nasync function actionGlobalOpenStateFile(pinia) {\r\n    try {\r\n        const open = await getFileOpener();\r\n        const result = await open();\r\n        if (!result)\r\n            return;\r\n        const { text, file } = result;\r\n        pinia.state.value = JSON.parse(text);\r\n        toastMessage(`Global state imported from \"${file.name}\".`);\r\n    }\r\n    catch (error) {\r\n        toastMessage(`Failed to export the state as JSON. Check the console for more details.`, 'error');\r\n        console.error(error);\r\n    }\r\n}\n\nfunction formatDisplay(display) {\r\n    return {\r\n        _custom: {\r\n            display,\r\n        },\r\n    };\r\n}\r\nconst PINIA_ROOT_LABEL = '\uD83C\uDF4D Pinia (root)';\r\nconst PINIA_ROOT_ID = '_root';\r\nfunction formatStoreForInspectorTree(store) {\r\n    return '$id' in store\r\n        ? {\r\n            id: store.$id,\r\n            label: store.$id,\r\n        }\r\n        : {\r\n            id: PINIA_ROOT_ID,\r\n            label: PINIA_ROOT_LABEL,\r\n        };\r\n}\r\nfunction formatStoreForInspectorState(store) {\r\n    if (isPinia(store)) {\r\n        const state = {\r\n            state: Object.keys(store.state.value).map((storeId) => ({\r\n                editable: true,\r\n                key: storeId,\r\n                value: store.state.value[storeId],\r\n            })),\r\n        };\r\n        // TODO: use this version when possible\r\n        // Object.keys(store.state.value).forEach((storeId) => {\r\n        //   const currentState = store.state.value[storeId]\r\n        //   state[storeId] = Object.keys(currentState).map((key) => ({\r\n        //     // is not possible to made editable because no way to get the storeId in\r\n        //     // edit inspector state callback\r\n        //     editable: false,\r\n        //     key,\r\n        //     value: currentState[key],\r\n        //   }))\r\n        // })\r\n        return state;\r\n    }\r\n    const state = {\r\n        state: Object.keys(store.$state).map((key) => ({\r\n            editable: true,\r\n            key,\r\n            value: store.$state[key],\r\n        })),\r\n    };\r\n    // avoid adding empty getters\r\n    if (store._getters && store._getters.length) {\r\n        state.getters = store._getters.map((getterName) => ({\r\n            editable: false,\r\n            key: getterName,\r\n            value: store[getterName],\r\n        }));\r\n    }\r\n    if (store._customProperties.size) {\r\n        state.customProperties = Array.from(store._customProperties).map((key) => ({\r\n            editable: true,\r\n            key,\r\n            value: store[key],\r\n        }));\r\n    }\r\n    return state;\r\n}\r\nfunction formatEventData(events) {\r\n    if (!events)\r\n        return {};\r\n    if (Array.isArray(events)) {\r\n        // TODO: handle add and delete for arrays and objects\r\n        return events.reduce((data, event) => {\r\n            data.keys.push(event.key);\r\n            data.operations.push(event.type);\r\n            data.oldValue[event.key] = event.oldValue;\r\n            data.newValue[event.key] = event.newValue;\r\n            return data;\r\n        }, {\r\n            oldValue: {},\r\n            keys: [],\r\n            operations: [],\r\n            newValue: {},\r\n        });\r\n    }\r\n    else {\r\n        return {\r\n            operation: formatDisplay(events.type),\r\n            key: formatDisplay(events.key),\r\n            oldValue: events.oldValue,\r\n            newValue: events.newValue,\r\n        };\r\n    }\r\n}\r\nfunction formatMutationType(type) {\r\n    switch (type) {\r\n        case MutationType.direct:\r\n            return 'mutation';\r\n        case MutationType.patchFunction:\r\n            return '$patch';\r\n        case MutationType.patchObject:\r\n            return '$patch';\r\n        default:\r\n            return 'unknown';\r\n    }\r\n}\n\n// timeline can be paused when directly changing the state\r\nlet isTimelineActive = true;\r\nconst componentStateTypes = [];\r\nconst MUTATIONS_LAYER_ID = 'pinia:mutations';\r\nconst INSPECTOR_ID = 'pinia';\r\n/**\r\n * Gets the displayed name of a store in devtools\r\n *\r\n * @param id - id of the store\r\n * @returns a formatted string\r\n */\r\nconst getStoreType = (id) => '\uD83C\uDF4D ' + id;\r\n/**\r\n * Add the pinia plugin without any store. Allows displaying a Pinia plugin tab\r\n * as soon as it is added to the application.\r\n *\r\n * @param app - Vue application\r\n * @param pinia - pinia instance\r\n */\r\nfunction registerPiniaDevtools(app, pinia) {\r\n    setupDevtoolsPlugin({\r\n        id: 'dev.esm.pinia',\r\n        label: 'Pinia \uD83C\uDF4D',\r\n        logo: 'https://pinia.esm.dev/logo.svg',\r\n        packageName: 'pinia',\r\n        homepage: 'https://pinia.esm.dev',\r\n        componentStateTypes,\r\n        app,\r\n    }, (api) => {\r\n        api.addTimelineLayer({\r\n            id: MUTATIONS_LAYER_ID,\r\n            label: `Pinia \uD83C\uDF4D`,\r\n            color: 0xe5df88,\r\n        });\r\n        api.addInspector({\r\n            id: INSPECTOR_ID,\r\n            label: 'Pinia \uD83C\uDF4D',\r\n            icon: 'storage',\r\n            treeFilterPlaceholder: 'Search stores',\r\n            actions: [\r\n                {\r\n                    icon: 'content_copy',\r\n                    action: () => {\r\n                        actionGlobalCopyState(pinia);\r\n                    },\r\n                    tooltip: 'Serialize and copy the state',\r\n                },\r\n                {\r\n                    icon: 'content_paste',\r\n                    action: async () => {\r\n                        await actionGlobalPasteState(pinia);\r\n                        api.sendInspectorTree(INSPECTOR_ID);\r\n                        api.sendInspectorState(INSPECTOR_ID);\r\n                    },\r\n                    tooltip: 'Replace the state with the content of your clipboard',\r\n                },\r\n                {\r\n                    icon: 'save',\r\n                    action: () => {\r\n                        actionGlobalSaveState(pinia);\r\n                    },\r\n                    tooltip: 'Save the state as a JSON file',\r\n                },\r\n                {\r\n                    icon: 'folder_open',\r\n                    action: async () => {\r\n                        await actionGlobalOpenStateFile(pinia);\r\n                        api.sendInspectorTree(INSPECTOR_ID);\r\n                        api.sendInspectorState(INSPECTOR_ID);\r\n                    },\r\n                    tooltip: 'Import the state from a JSON file',\r\n                },\r\n            ],\r\n        });\r\n        api.on.inspectComponent((payload, ctx) => {\r\n            const proxy = (payload.componentInstance &&\r\n                payload.componentInstance.proxy);\r\n            if (proxy && proxy._pStores) {\r\n                const piniaStores = payload.componentInstance.proxy._pStores;\r\n                Object.values(piniaStores).forEach((store) => {\r\n                    payload.instanceData.state.push({\r\n                        type: getStoreType(store.$id),\r\n                        key: 'state',\r\n                        editable: true,\r\n                        value: store.$state,\r\n                    });\r\n                    if (store._getters && store._getters.length) {\r\n                        payload.instanceData.state.push({\r\n                            type: getStoreType(store.$id),\r\n                            key: 'getters',\r\n                            editable: false,\r\n                            value: store._getters.reduce((getters, key) => {\r\n                                getters[key] = store[key];\r\n                                return getters;\r\n                            }, {}),\r\n                        });\r\n                    }\r\n                });\r\n            }\r\n        });\r\n        api.on.getInspectorTree((payload) => {\r\n            if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {\r\n                let stores = [pinia];\r\n                stores = stores.concat(Array.from(pinia._s.values()));\r\n                payload.rootNodes = (payload.filter\r\n                    ? stores.filter((store) => '$id' in store\r\n                        ? store.$id\r\n                            .toLowerCase()\r\n                            .includes(payload.filter.toLowerCase())\r\n                        : PINIA_ROOT_LABEL.toLowerCase().includes(payload.filter.toLowerCase()))\r\n                    : stores).map(formatStoreForInspectorTree);\r\n            }\r\n        });\r\n        api.on.getInspectorState((payload) => {\r\n            if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {\r\n                const inspectedStore = payload.nodeId === PINIA_ROOT_ID\r\n                    ? pinia\r\n                    : pinia._s.get(payload.nodeId);\r\n                if (!inspectedStore) {\r\n                    // this could be the selected store restored for a different project\r\n                    // so it's better not to say anything here\r\n                    return;\r\n                }\r\n                if (inspectedStore) {\r\n                    payload.state = formatStoreForInspectorState(inspectedStore);\r\n                }\r\n            }\r\n        });\r\n        api.on.editInspectorState((payload, ctx) => {\r\n            if (payload.app === app && payload.inspectorId === INSPECTOR_ID) {\r\n                const inspectedStore = payload.nodeId === PINIA_ROOT_ID\r\n                    ? pinia\r\n                    : pinia._s.get(payload.nodeId);\r\n                if (!inspectedStore) {\r\n                    return toastMessage(`store \"${payload.nodeId}\" not found`, 'error');\r\n                }\r\n                const { path } = payload;\r\n                if (!isPinia(inspectedStore)) {\r\n                    // access only the state\r\n                    if (path.length !== 1 ||\r\n                        !inspectedStore._customProperties.has(path[0]) ||\r\n                        path[0] in inspectedStore.$state) {\r\n                        path.unshift('$state');\r\n                    }\r\n                }\r\n                else {\r\n                    path.unshift('state', 'value');\r\n                }\r\n                isTimelineActive = false;\r\n                payload.set(inspectedStore, path, payload.state.value);\r\n                isTimelineActive = true;\r\n            }\r\n        });\r\n        api.on.editComponentState((payload) => {\r\n            if (payload.type.startsWith('\uD83C\uDF4D')) {\r\n                const storeId = payload.type.replace(/^\uD83C\uDF4D\\s*/, '');\r\n                const store = pinia._s.get(storeId);\r\n                if (!store) {\r\n                    return toastMessage(`store \"${storeId}\" not found`, 'error');\r\n                }\r\n                const { path } = payload;\r\n                if (path[0] !== 'state') {\r\n                    return toastMessage(`Invalid path for store \"${storeId}\":\\n${path}\\nOnly state can be modified.`);\r\n                }\r\n                // rewrite the first entry to be able to directly set the state as\r\n                // well as any other path\r\n                path[0] = '$state';\r\n                isTimelineActive = false;\r\n                payload.set(store, path, payload.state.value);\r\n                isTimelineActive = true;\r\n            }\r\n        });\r\n    });\r\n}\r\nfunction addStoreToDevtools(app, store) {\r\n    if (!componentStateTypes.includes(getStoreType(store.$id))) {\r\n        componentStateTypes.push(getStoreType(store.$id));\r\n    }\r\n    setupDevtoolsPlugin({\r\n        id: 'dev.esm.pinia',\r\n        label: 'Pinia \uD83C\uDF4D',\r\n        logo: 'https://pinia.esm.dev/logo.svg',\r\n        packageName: 'pinia',\r\n        homepage: 'https://pinia.esm.dev',\r\n        componentStateTypes,\r\n        app,\r\n    }, (api) => {\r\n        store.$onAction(({ after, onError, name, args }) => {\r\n            const groupId = runningActionId++;\r\n            api.addTimelineEvent({\r\n                layerId: MUTATIONS_LAYER_ID,\r\n                event: {\r\n                    time: Date.now(),\r\n                    title: '\uD83D\uDEEB ' + name,\r\n                    subtitle: 'start',\r\n                    data: {\r\n                        store: formatDisplay(store.$id),\r\n                        action: formatDisplay(name),\r\n                        args,\r\n                    },\r\n                    groupId,\r\n                },\r\n            });\r\n            after((result) => {\r\n                activeAction = undefined;\r\n                api.addTimelineEvent({\r\n                    layerId: MUTATIONS_LAYER_ID,\r\n                    event: {\r\n                        time: Date.now(),\r\n                        title: '\uD83D\uDEEC ' + name,\r\n                        subtitle: 'end',\r\n                        data: {\r\n                            store: formatDisplay(store.$id),\r\n                            action: formatDisplay(name),\r\n                            args,\r\n                            result,\r\n                        },\r\n                        groupId,\r\n                    },\r\n                });\r\n            });\r\n            onError((error) => {\r\n                activeAction = undefined;\r\n                api.addTimelineEvent({\r\n                    layerId: MUTATIONS_LAYER_ID,\r\n                    event: {\r\n                        time: Date.now(),\r\n                        logType: 'error',\r\n                        title: '\uD83D\uDCA5 ' + name,\r\n                        subtitle: 'end',\r\n                        data: {\r\n                            store: formatDisplay(store.$id),\r\n                            action: formatDisplay(name),\r\n                            args,\r\n                            error,\r\n                        },\r\n                        groupId,\r\n                    },\r\n                });\r\n            });\r\n        }, true);\r\n        store._customProperties.forEach((name) => {\r\n            watch(() => unref(store[name]), (newValue, oldValue) => {\r\n                api.notifyComponentUpdate();\r\n                api.sendInspectorState(INSPECTOR_ID);\r\n                if (isTimelineActive) {\r\n                    api.addTimelineEvent({\r\n                        layerId: MUTATIONS_LAYER_ID,\r\n                        event: {\r\n                            time: Date.now(),\r\n                            title: 'Change',\r\n                            subtitle: name,\r\n                            data: {\r\n                                newValue,\r\n                                oldValue,\r\n                            },\r\n                            groupId: activeAction,\r\n                        },\r\n                    });\r\n                }\r\n            }, { deep: true });\r\n        });\r\n        store.$subscribe(({ events, type }, state) => {\r\n            api.notifyComponentUpdate();\r\n            api.sendInspectorState(INSPECTOR_ID);\r\n            if (!isTimelineActive)\r\n                return;\r\n            // rootStore.state[store.id] = state\r\n            const eventData = {\r\n                time: Date.now(),\r\n                title: formatMutationType(type),\r\n                data: {\r\n                    store: formatDisplay(store.$id),\r\n                    ...formatEventData(events),\r\n                },\r\n                groupId: activeAction,\r\n            };\r\n            // reset for the next mutation\r\n            activeAction = undefined;\r\n            if (type === MutationType.patchFunction) {\r\n                eventData.subtitle = '\u2935\uFE0F';\r\n            }\r\n            else if (type === MutationType.patchObject) {\r\n                eventData.subtitle = '\uD83E\uDDE9';\r\n            }\r\n            else if (events && !Array.isArray(events)) {\r\n                eventData.subtitle = events.type;\r\n            }\r\n            if (events) {\r\n                eventData.data['rawEvent(s)'] = {\r\n                    _custom: {\r\n                        display: 'DebuggerEvent',\r\n                        type: 'object',\r\n                        tooltip: 'raw DebuggerEvent[]',\r\n                        value: events,\r\n                    },\r\n                };\r\n            }\r\n            api.addTimelineEvent({\r\n                layerId: MUTATIONS_LAYER_ID,\r\n                event: eventData,\r\n            });\r\n        }, { detached: true, flush: 'sync' });\r\n        const hotUpdate = store._hotUpdate;\r\n        store._hotUpdate = markRaw((newStore) => {\r\n            hotUpdate(newStore);\r\n            api.addTimelineEvent({\r\n                layerId: MUTATIONS_LAYER_ID,\r\n                event: {\r\n                    time: Date.now(),\r\n                    title: '\uD83D\uDD25 ' + store.$id,\r\n                    subtitle: 'HMR update',\r\n                    data: {\r\n                        store: formatDisplay(store.$id),\r\n                        info: formatDisplay(`HMR update`),\r\n                    },\r\n                },\r\n            });\r\n            // update the devtools too\r\n            api.notifyComponentUpdate();\r\n            api.sendInspectorTree(INSPECTOR_ID);\r\n            api.sendInspectorState(INSPECTOR_ID);\r\n        });\r\n        const { $dispose } = store;\r\n        store.$dispose = () => {\r\n            $dispose();\r\n            api.notifyComponentUpdate();\r\n            api.sendInspectorTree(INSPECTOR_ID);\r\n            api.sendInspectorState(INSPECTOR_ID);\r\n            toastMessage(`Disposed \"${store.$id}\" store \uD83D\uDDD1`);\r\n        };\r\n        // trigger an update so it can display new registered stores\r\n        api.notifyComponentUpdate();\r\n        api.sendInspectorTree(INSPECTOR_ID);\r\n        api.sendInspectorState(INSPECTOR_ID);\r\n        toastMessage(`\"${store.$id}\" store installed \uD83C\uDD95`);\r\n    });\r\n}\r\nlet runningActionId = 0;\r\nlet activeAction;\r\n/**\r\n * Patches a store to enable action grouping in devtools by wrapping the store with a Proxy that is passed as the context of all actions, allowing us to set `runningAction` on each access and effectively associating any state mutation to the action.\r\n *\r\n * @param store - store to patch\r\n * @param actionNames - list of actionst to patch\r\n */\r\nfunction patchActionForGrouping(store, actionNames) {\r\n    // original actions of the store as they are given by pinia. We are going to override them\r\n    const actions = actionNames.reduce((storeActions, actionName) => {\r\n        // use toRaw to avoid tracking #541\r\n        storeActions[actionName] = toRaw(store)[actionName];\r\n        return storeActions;\r\n    }, {});\r\n    for (const actionName in actions) {\r\n        store[actionName] = function () {\r\n            // setActivePinia(store._p)\r\n            // the running action id is incremented in a before action hook\r\n            const _actionId = runningActionId;\r\n            const trackedStore = new Proxy(store, {\r\n                get(...args) {\r\n                    activeAction = _actionId;\r\n                    return Reflect.get(...args);\r\n                },\r\n                set(...args) {\r\n                    activeAction = _actionId;\r\n                    return Reflect.set(...args);\r\n                },\r\n            });\r\n            return actions[actionName].apply(trackedStore, arguments);\r\n        };\r\n    }\r\n}\r\n/**\r\n * pinia.use(devtoolsPlugin)\r\n */\r\nfunction devtoolsPlugin({ app, store, options }) {\r\n    // HMR module\r\n    if (store.$id.startsWith('__hot:')) {\r\n        return;\r\n    }\r\n    // only wrap actions in option-defined stores as this technique relies on\r\n    // wrapping the context of the action with a proxy\r\n    if (typeof options.state === 'function') {\r\n        patchActionForGrouping(\r\n        // @ts-expect-error: can cast the store...\r\n        store, Object.keys(options.actions));\r\n        const originalHotUpdate = store._hotUpdate;\r\n        // Upgrade the HMR to also update the new actions\r\n        toRaw(store)._hotUpdate = function (newStore) {\r\n            originalHotUpdate.apply(this, arguments);\r\n            patchActionForGrouping(store, Object.keys(newStore._hmrPayload.actions));\r\n        };\r\n    }\r\n    addStoreToDevtools(app, \r\n    // FIXME: is there a way to allow the assignment from Store<Id, S, G, A> to StoreGeneric?\r\n    store);\r\n}\n\n/**\r\n * Creates a Pinia instance to be used by the application\r\n */\r\nfunction createPinia() {\r\n    const scope = effectScope(true);\r\n    // NOTE: here we could check the window object for a state and directly set it\r\n    // if there is anything like it with Vue 3 SSR\r\n    const state = scope.run(() => ref({}));\r\n    let _p = [];\r\n    // plugins added before calling app.use(pinia)\r\n    const toBeInstalled = [];\r\n    const pinia = markRaw({\r\n        install(app) {\r\n            // this allows calling useStore() outside of a component setup after\r\n            // installing pinia's plugin\r\n            setActivePinia(pinia);\r\n            if (!isVue2) {\r\n                pinia._a = app;\r\n                app.provide(piniaSymbol, pinia);\r\n                app.config.globalProperties.$pinia = pinia;\r\n                /* istanbul ignore else */\r\n                if ((process.env.NODE_ENV !== 'production') && IS_CLIENT) {\r\n                    registerPiniaDevtools(app, pinia);\r\n                }\r\n                toBeInstalled.forEach((plugin) => _p.push(plugin));\r\n            }\r\n        },\r\n        use(plugin) {\r\n            if (!this._a && !isVue2) {\r\n                toBeInstalled.push(plugin);\r\n            }\r\n            else {\r\n                _p.push(plugin);\r\n            }\r\n            return this;\r\n        },\r\n        _p,\r\n        // it's actually undefined here\r\n        // @ts-expect-error\r\n        _a: null,\r\n        _e: scope,\r\n        _s: new Map(),\r\n        state,\r\n    });\r\n    // pinia devtools rely on dev only features so they cannot be forced unless\r\n    // the dev build of Vue is used\r\n    if ((process.env.NODE_ENV !== 'production') && IS_CLIENT) {\r\n        pinia.use(devtoolsPlugin);\r\n    }\r\n    return pinia;\r\n}\n\n/**\r\n * Checks if a function is a `StoreDefinition`.\r\n *\r\n * @param fn - object to test\r\n * @returns true if `fn` is a StoreDefinition\r\n */\r\nconst isUseStore = (fn) => {\r\n    return typeof fn === 'function' && typeof fn.$id === 'string';\r\n};\r\n/**\r\n * Mutates in place `newState` with `oldState` to _hot update_ it. It will\r\n * remove any key not existing in `newState` and recursively merge plain\r\n * objects.\r\n *\r\n * @param newState - new state object to be patched\r\n * @param oldState - old state that should be used to patch newState\r\n * @returns - newState\r\n */\r\nfunction patchObject(newState, oldState) {\r\n    // no need to go through symbols because they cannot be serialized anyway\r\n    for (const key in oldState) {\r\n        const subPatch = oldState[key];\r\n        // skip the whole sub tree\r\n        if (!(key in newState)) {\r\n            continue;\r\n        }\r\n        const targetValue = newState[key];\r\n        if (isPlainObject(targetValue) &&\r\n            isPlainObject(subPatch) &&\r\n            !isRef(subPatch) &&\r\n            !isReactive(subPatch)) {\r\n            newState[key] = patchObject(targetValue, subPatch);\r\n        }\r\n        else {\r\n            // objects are either a bit more complex (e.g. refs) or primitives, so we\r\n            // just set the whole thing\r\n            if (isVue2) {\r\n                set(newState, key, subPatch);\r\n            }\r\n            else {\r\n                newState[key] = subPatch;\r\n            }\r\n        }\r\n    }\r\n    return newState;\r\n}\r\n/**\r\n * Creates an _accept_ function to pass to `import.meta.hot` in Vite applications.\r\n *\r\n * @example\r\n * ```js\r\n * const useUser = defineStore(...)\r\n * if (import.meta.hot) {\r\n *   import.meta.hot.accept(acceptHMRUpdate(useUser, import.meta.hot))\r\n * }\r\n * ```\r\n *\r\n * @param initialUseStore - return of the defineStore to hot update\r\n * @param hot - `import.meta.hot`\r\n */\r\nfunction acceptHMRUpdate(initialUseStore, hot) {\r\n    return (newModule) => {\r\n        const pinia = hot.data.pinia || initialUseStore._pinia;\r\n        if (!pinia) {\r\n            // this store is still not used\r\n            return;\r\n        }\r\n        // preserve the pinia instance across loads\r\n        hot.data.pinia = pinia;\r\n        // console.log('got data', newStore)\r\n        for (const exportName in newModule) {\r\n            const useStore = newModule[exportName];\r\n            // console.log('checking for', exportName)\r\n            if (isUseStore(useStore) && pinia._s.has(useStore.$id)) {\r\n                // console.log('Accepting update for', useStore.$id)\r\n                const id = useStore.$id;\r\n                if (id !== initialUseStore.$id) {\r\n                    console.warn(`The id of the store changed from \"${initialUseStore.$id}\" to \"${id}\". Reloading.`);\r\n                    // return import.meta.hot.invalidate()\r\n                    return hot.invalidate();\r\n                }\r\n                const existingStore = pinia._s.get(id);\r\n                if (!existingStore) {\r\n                    console.log(`skipping hmr because store doesn't exist yet`);\r\n                    return;\r\n                }\r\n                useStore(pinia, existingStore);\r\n            }\r\n        }\r\n    };\r\n}\n\nfunction addSubscription(subscriptions, callback, detached) {\r\n    subscriptions.push(callback);\r\n    const removeSubscription = () => {\r\n        const idx = subscriptions.indexOf(callback);\r\n        if (idx > -1) {\r\n            subscriptions.splice(idx, 1);\r\n        }\r\n    };\r\n    if (!detached && getCurrentInstance()) {\r\n        onUnmounted(removeSubscription);\r\n    }\r\n    return removeSubscription;\r\n}\r\nfunction triggerSubscriptions(subscriptions, ...args) {\r\n    subscriptions.forEach((callback) => {\r\n        callback(...args);\r\n    });\r\n}\n\nfunction innerPatch(target, patchToApply) {\r\n    // no need to go through symbols because they cannot be serialized anyway\r\n    for (const key in patchToApply) {\r\n        const subPatch = patchToApply[key];\r\n        const targetValue = target[key];\r\n        if (isPlainObject(targetValue) &&\r\n            isPlainObject(subPatch) &&\r\n            !isRef(subPatch) &&\r\n            !isReactive(subPatch)) {\r\n            target[key] = innerPatch(targetValue, subPatch);\r\n        }\r\n        else {\r\n            // @ts-expect-error: subPatch is a valid value\r\n            target[key] = subPatch;\r\n        }\r\n    }\r\n    return target;\r\n}\r\nconst { assign } = Object;\r\nfunction isComputed(o) {\r\n    if (isVue2) {\r\n        const descriptor = o ? Object.getOwnPropertyDescriptor(o, 'value') : null;\r\n        return (descriptor &&\r\n            descriptor.get &&\r\n            // TODO: make something in @vue/composition-api to be able to check this\r\n            descriptor.get.toString().length > 42);\r\n    }\r\n    return o && o.effect;\r\n}\r\nfunction createOptionsStore(id, options, pinia, hot) {\r\n    const { state, actions, getters } = options;\r\n    const initialState = pinia.state.value[id];\r\n    let store;\r\n    function setup() {\r\n        if (!initialState && (!(process.env.NODE_ENV !== 'production') || !hot)) {\r\n            if (isVue2) {\r\n                set(pinia.state.value, id, state ? state() : {});\r\n            }\r\n            else {\r\n                pinia.state.value[id] = state ? state() : {};\r\n            }\r\n        }\r\n        // avoid creating a state in pinia.state.value\r\n        const localState = (process.env.NODE_ENV !== 'production') && hot\r\n            ? // use ref() to unwrap refs inside state TODO: check if this is still necessary\r\n                toRefs(ref(state ? state() : {}).value)\r\n            : toRefs(pinia.state.value[id]);\r\n        return assign(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name) => {\r\n            computedGetters[name] = markRaw(computed(() => {\r\n                setActivePinia(pinia);\r\n                // it was created just before\r\n                const store = pinia._s.get(id);\r\n                // allow cross using stores\r\n                if (isVue2 && !store._r)\r\n                    return;\r\n                // @ts-expect-error\r\n                // return getters![name].call(context, context)\r\n                // TODO: avoid reading the getter while assigning with a global variable\r\n                return getters[name].call(store, store);\r\n            }));\r\n            return computedGetters;\r\n        }, {}));\r\n    }\r\n    store = createSetupStore(id, setup, options, pinia, hot);\r\n    store.$reset = function $reset() {\r\n        const newState = state ? state() : {};\r\n        // we use a patch to group all changes into one single subscription\r\n        this.$patch(($state) => {\r\n            assign($state, newState);\r\n        });\r\n    };\r\n    return store;\r\n}\r\nconst noop = () => { };\r\nfunction createSetupStore($id, setup, options = {}, pinia, hot) {\r\n    let scope;\r\n    const buildState = options.state;\r\n    const optionsForPlugin = {\r\n        actions: {},\r\n        ...options,\r\n    };\r\n    /* istanbul ignore if */\r\n    if ((process.env.NODE_ENV !== 'production') && !pinia._e.active) {\r\n        throw new Error('Pinia destroyed');\r\n    }\r\n    // watcher options for $subscribe\r\n    const $subscribeOptions = {\r\n        deep: true,\r\n        // flush: 'post',\r\n    };\r\n    /* istanbul ignore else */\r\n    if ((process.env.NODE_ENV !== 'production') && !isVue2) {\r\n        $subscribeOptions.onTrigger = (event) => {\r\n            /* istanbul ignore else */\r\n            if (isListening) {\r\n                debuggerEvents = event;\r\n                // avoid triggering this while the store is being built and the state is being set in pinia\r\n            }\r\n            else if (isListening == false && !store._hotUpdating) {\r\n                // let patch send all the events together later\r\n                /* istanbul ignore else */\r\n                if (Array.isArray(debuggerEvents)) {\r\n                    debuggerEvents.push(event);\r\n                }\r\n                else {\r\n                    console.error('\uD83C\uDF4D debuggerEvents should be an array. This is most likely an internal Pinia bug.');\r\n                }\r\n            }\r\n        };\r\n    }\r\n    // internal state\r\n    let isListening; // set to true at the end\r\n    let subscriptions = markRaw([]);\r\n    let actionSubscriptions = markRaw([]);\r\n    let debuggerEvents;\r\n    const initialState = pinia.state.value[$id];\r\n    if (!initialState && (!(process.env.NODE_ENV !== 'production') || !hot)) {\r\n        if (isVue2) {\r\n            set(pinia.state.value, $id, {});\r\n        }\r\n        else {\r\n            pinia.state.value[$id] = {};\r\n        }\r\n    }\r\n    const hotState = ref({});\r\n    function $patch(partialStateOrMutator) {\r\n        let subscriptionMutation;\r\n        isListening = false;\r\n        // reset the debugger events since patches are sync\r\n        /* istanbul ignore else */\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            debuggerEvents = [];\r\n        }\r\n        if (typeof partialStateOrMutator === 'function') {\r\n            partialStateOrMutator(pinia.state.value[$id]);\r\n            subscriptionMutation = {\r\n                type: MutationType.patchFunction,\r\n                storeId: $id,\r\n                events: debuggerEvents,\r\n            };\r\n        }\r\n        else {\r\n            innerPatch(pinia.state.value[$id], partialStateOrMutator);\r\n            subscriptionMutation = {\r\n                type: MutationType.patchObject,\r\n                payload: partialStateOrMutator,\r\n                storeId: $id,\r\n                events: debuggerEvents,\r\n            };\r\n        }\r\n        isListening = true;\r\n        // because we paused the watcher, we need to manually call the subscriptions\r\n        triggerSubscriptions(subscriptions, subscriptionMutation, pinia.state.value[$id]);\r\n    }\r\n    /* istanbul ignore next */\r\n    const $reset = (process.env.NODE_ENV !== 'production')\r\n        ? () => {\r\n            throw new Error(`\uD83C\uDF4D: Store \"${$id}\" is build using the setup syntax and does not implement $reset().`);\r\n        }\r\n        : noop;\r\n    function $dispose() {\r\n        scope.stop();\r\n        subscriptions = [];\r\n        actionSubscriptions = [];\r\n        pinia._s.delete($id);\r\n    }\r\n    /**\r\n     * Wraps an action to handle subscriptions.\r\n     *\r\n     * @param name - name of the action\r\n     * @param action - action to wrap\r\n     * @returns a wrapped action to handle subscriptions\r\n     */\r\n    function wrapAction(name, action) {\r\n        return function () {\r\n            setActivePinia(pinia);\r\n            const args = Array.from(arguments);\r\n            let afterCallback = noop;\r\n            let onErrorCallback = noop;\r\n            function after(callback) {\r\n                afterCallback = callback;\r\n            }\r\n            function onError(callback) {\r\n                onErrorCallback = callback;\r\n            }\r\n            // @ts-expect-error\r\n            triggerSubscriptions(actionSubscriptions, {\r\n                args,\r\n                name,\r\n                store,\r\n                after,\r\n                onError,\r\n            });\r\n            let ret;\r\n            try {\r\n                ret = action.apply(this && this.$id === $id ? this : store, args);\r\n                // handle sync errors\r\n            }\r\n            catch (error) {\r\n                if (onErrorCallback(error) !== false) {\r\n                    throw error;\r\n                }\r\n            }\r\n            if (ret instanceof Promise) {\r\n                return ret\r\n                    .then((value) => {\r\n                    const newRet = afterCallback(value);\r\n                    // allow the afterCallback to override the return value\r\n                    return newRet === undefined ? value : newRet;\r\n                })\r\n                    .catch((error) => {\r\n                    if (onErrorCallback(error) !== false) {\r\n                        return Promise.reject(error);\r\n                    }\r\n                });\r\n            }\r\n            // allow the afterCallback to override the return value\r\n            const newRet = afterCallback(ret);\r\n            return newRet === undefined ? ret : newRet;\r\n        };\r\n    }\r\n    const _hmrPayload = /*#__PURE__*/ markRaw({\r\n        actions: {},\r\n        getters: {},\r\n        state: [],\r\n        hotState,\r\n    });\r\n    const partialStore = {\r\n        _p: pinia,\r\n        // _s: scope,\r\n        $id,\r\n        $onAction: addSubscription.bind(null, actionSubscriptions),\r\n        $patch,\r\n        $reset,\r\n        $subscribe(callback, options = {}) {\r\n            /* istanbul ignore if */\r\n            if ((process.env.NODE_ENV !== 'production') && typeof options === 'boolean') {\r\n                console.warn(`[\uD83C\uDF4D]: store.$subscribe() no longer accepts a boolean as the 2nd parameter:\\n` +\r\n                    `Replace \"store.$subscribe(fn, ${String(options)})\" with \"store.$subscribe(fn, { detached: ${String(options)} })\".\\nThis will fail in production.`);\r\n                options = { detached: options };\r\n            }\r\n            const _removeSubscription = addSubscription(subscriptions, callback, \r\n            // @ts-expect-error: until the deprecation is removed\r\n            options.detached);\r\n            const stopWatcher = scope.run(() => watch(() => pinia.state.value[$id], (state, oldState) => {\r\n                if (isListening) {\r\n                    callback({\r\n                        storeId: $id,\r\n                        type: MutationType.direct,\r\n                        events: debuggerEvents,\r\n                    }, state);\r\n                }\r\n            }, assign({}, $subscribeOptions, options)));\r\n            const removeSubscription = () => {\r\n                stopWatcher();\r\n                _removeSubscription();\r\n            };\r\n            return removeSubscription;\r\n        },\r\n        $dispose,\r\n    };\r\n    if (isVue2) {\r\n        // start as non ready\r\n        partialStore._r = false;\r\n    }\r\n    const store = reactive(assign((process.env.NODE_ENV !== 'production') && IS_CLIENT\r\n        ? // devtools custom properties\r\n            {\r\n                _customProperties: markRaw(new Set()),\r\n                _hmrPayload,\r\n            }\r\n        : {}, partialStore\r\n    // must be added later\r\n    // setupStore\r\n    ));\r\n    // store the partial store now so the setup of stores can instantiate each other before they are finished without\r\n    // creating infinite loops.\r\n    pinia._s.set($id, store);\r\n    // TODO: idea create skipSerialize that marks properties as non serializable and they are skipped\r\n    const setupStore = pinia._e.run(() => {\r\n        scope = effectScope();\r\n        return scope.run(() => setup());\r\n    });\r\n    // overwrite existing actions to support $onAction\r\n    for (const key in setupStore) {\r\n        const prop = setupStore[key];\r\n        if ((isRef(prop) && !isComputed(prop)) || isReactive(prop)) {\r\n            // mark it as a piece of state to be serialized\r\n            if ((process.env.NODE_ENV !== 'production') && hot) {\r\n                set(hotState.value, key, toRef(setupStore, key));\r\n                // createOptionStore directly sets the state in pinia.state.value so we\r\n                // can just skip that\r\n            }\r\n            else if (!buildState) {\r\n                // in setup stores we must hydrate the state and sync pinia state tree with the refs the user just created\r\n                if (initialState) {\r\n                    if (isRef(prop)) {\r\n                        prop.value = initialState[key];\r\n                    }\r\n                    else {\r\n                        // probably a reactive object, lets recursively assign\r\n                        innerPatch(prop, initialState[key]);\r\n                    }\r\n                }\r\n                // transfer the ref to the pinia state to keep everything in sync\r\n                if (isVue2) {\r\n                    set(pinia.state.value[$id], key, prop);\r\n                }\r\n                else {\r\n                    pinia.state.value[$id][key] = prop;\r\n                }\r\n            }\r\n            /* istanbul ignore else */\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                _hmrPayload.state.push(key);\r\n            }\r\n            // action\r\n        }\r\n        else if (typeof prop === 'function') {\r\n            // @ts-expect-error: we are overriding the function we avoid wrapping if\r\n            const actionValue = (process.env.NODE_ENV !== 'production') && hot ? prop : wrapAction(key, prop);\r\n            // this a hot module replacement store because the hotUpdate method needs\r\n            // to do it with the right context\r\n            if (isVue2) {\r\n                set(setupStore, key, actionValue);\r\n            }\r\n            else {\r\n                // @ts-expect-error\r\n                setupStore[key] = actionValue;\r\n            }\r\n            /* istanbul ignore else */\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                _hmrPayload.actions[key] = prop;\r\n            }\r\n            // list actions so they can be used in plugins\r\n            // @ts-expect-error\r\n            optionsForPlugin.actions[key] = prop;\r\n        }\r\n        else if ((process.env.NODE_ENV !== 'production')) {\r\n            // add getters for devtools\r\n            if (isComputed(prop)) {\r\n                _hmrPayload.getters[key] = buildState\r\n                    ? // @ts-expect-error\r\n                        options.getters[key]\r\n                    : prop;\r\n                if (IS_CLIENT) {\r\n                    const getters = \r\n                    // @ts-expect-error: it should be on the store\r\n                    setupStore._getters || (setupStore._getters = markRaw([]));\r\n                    getters.push(key);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    // add the state, getters, and action properties\r\n    if (isVue2) {\r\n        Object.keys(setupStore).forEach((key) => {\r\n            set(store, key, \r\n            // @ts-expect-error: valid key indexing\r\n            setupStore[key]);\r\n        });\r\n    }\r\n    else {\r\n        assign(store, setupStore);\r\n    }\r\n    // use this instead of a computed with setter to be able to create it anywhere\r\n    // without linking the computed lifespan to wherever the store is first\r\n    // created.\r\n    Object.defineProperty(store, '$state', {\r\n        get: () => ((process.env.NODE_ENV !== 'production') && hot ? hotState.value : pinia.state.value[$id]),\r\n        set: (state) => {\r\n            /* istanbul ignore if */\r\n            if ((process.env.NODE_ENV !== 'production') && hot) {\r\n                throw new Error('cannot set hotState');\r\n            }\r\n            $patch(($state) => {\r\n                assign($state, state);\r\n            });\r\n        },\r\n    });\r\n    // add the hotUpdate before plugins to allow them to override it\r\n    /* istanbul ignore else */\r\n    if ((process.env.NODE_ENV !== 'production')) {\r\n        store._hotUpdate = markRaw((newStore) => {\r\n            store._hotUpdating = true;\r\n            newStore._hmrPayload.state.forEach((stateKey) => {\r\n                if (stateKey in store.$state) {\r\n                    const newStateTarget = newStore.$state[stateKey];\r\n                    const oldStateSource = store.$state[stateKey];\r\n                    if (typeof newStateTarget === 'object' &&\r\n                        isPlainObject(newStateTarget) &&\r\n                        isPlainObject(oldStateSource)) {\r\n                        patchObject(newStateTarget, oldStateSource);\r\n                    }\r\n                    else {\r\n                        // transfer the ref\r\n                        newStore.$state[stateKey] = oldStateSource;\r\n                    }\r\n                }\r\n                // patch direct access properties to allow store.stateProperty to work as\r\n                // store.$state.stateProperty\r\n                set(store, stateKey, toRef(newStore.$state, stateKey));\r\n            });\r\n            // remove deleted state properties\r\n            Object.keys(store.$state).forEach((stateKey) => {\r\n                if (!(stateKey in newStore.$state)) {\r\n                    del(store, stateKey);\r\n                }\r\n            });\r\n            // avoid devtools logging this as a mutation\r\n            isListening = false;\r\n            pinia.state.value[$id] = toRef(newStore._hmrPayload, 'hotState');\r\n            isListening = true;\r\n            for (const actionName in newStore._hmrPayload.actions) {\r\n                const action = newStore[actionName];\r\n                set(store, actionName, wrapAction(actionName, action));\r\n            }\r\n            // TODO: does this work in both setup and option store?\r\n            for (const getterName in newStore._hmrPayload.getters) {\r\n                const getter = newStore._hmrPayload.getters[getterName];\r\n                const getterValue = buildState\r\n                    ? // special handling of options api\r\n                        computed(() => {\r\n                            setActivePinia(pinia);\r\n                            return getter.call(store, store);\r\n                        })\r\n                    : getter;\r\n                set(store, getterName, getterValue);\r\n            }\r\n            // remove deleted getters\r\n            Object.keys(store._hmrPayload.getters).forEach((key) => {\r\n                if (!(key in newStore._hmrPayload.getters)) {\r\n                    del(store, key);\r\n                }\r\n            });\r\n            // remove old actions\r\n            Object.keys(store._hmrPayload.actions).forEach((key) => {\r\n                if (!(key in newStore._hmrPayload.actions)) {\r\n                    del(store, key);\r\n                }\r\n            });\r\n            // update the values used in devtools and to allow deleting new properties later on\r\n            store._hmrPayload = newStore._hmrPayload;\r\n            store._getters = newStore._getters;\r\n            store._hotUpdating = false;\r\n        });\r\n        const nonEnumerable = {\r\n            writable: true,\r\n            configurable: true,\r\n            // avoid warning on devtools trying to display this property\r\n            enumerable: false,\r\n        };\r\n        if (IS_CLIENT) {\r\n            ['_p', '_hmrPayload', '_getters', '_customProperties'].forEach((p) => {\r\n                Object.defineProperty(store, p, {\r\n                    value: store[p],\r\n                    ...nonEnumerable,\r\n                });\r\n            });\r\n        }\r\n    }\r\n    if (isVue2) {\r\n        // mark the store as ready before pluginsn\r\n        store._r = true;\r\n    }\r\n    // apply all plugins\r\n    pinia._p.forEach((extender) => {\r\n        /* istanbul ignore else */\r\n        if ((process.env.NODE_ENV !== 'production') && IS_CLIENT) {\r\n            const extensions = scope.run(() => extender({\r\n                store,\r\n                app: pinia._a,\r\n                pinia,\r\n                // @ts-expect-error\r\n                options: optionsForPlugin,\r\n            }));\r\n            Object.keys(extensions || {}).forEach((key) => store._customProperties.add(key));\r\n            assign(store, extensions);\r\n        }\r\n        else {\r\n            assign(store, scope.run(() => extender({\r\n                store,\r\n                app: pinia._a,\r\n                pinia,\r\n                // @ts-expect-error\r\n                options: optionsForPlugin,\r\n            })));\r\n        }\r\n    });\r\n    if ((process.env.NODE_ENV !== 'production') &&\r\n        store.$state &&\r\n        typeof store.$state === 'object' &&\r\n        typeof store.$state.constructor === 'function' &&\r\n        !store.$state.constructor.toString().includes('[native code]')) {\r\n        console.warn(`[\uD83C\uDF4D]: The \"state\" must be a plain object. It cannot be\\n\\tstate: () => new MyClass()`);\r\n    }\r\n    // only apply hydrate to option stores with an initial state in pinia\r\n    if (initialState && buildState) {\r\n        (options.hydrate || innerPatch)(store, initialState);\r\n    }\r\n    isListening = true;\r\n    return store;\r\n}\r\nfunction defineStore(\r\n// TODO: add proper types from above\r\nidOrOptions, setup, setupOptions) {\r\n    let id;\r\n    let options;\r\n    const isSetupStore = typeof setup === 'function';\r\n    if (typeof idOrOptions === 'string') {\r\n        id = idOrOptions;\r\n        // the option store setup will contain the actual options in this case\r\n        options = isSetupStore ? setupOptions : setup;\r\n    }\r\n    else {\r\n        options = idOrOptions;\r\n        id = idOrOptions.id;\r\n    }\r\n    function useStore(pinia, hot) {\r\n        const currentInstance = getCurrentInstance();\r\n        pinia =\r\n            // in test mode, ignore the argument provided as we can always retrieve a\r\n            // pinia instance with getActivePinia()\r\n            ((process.env.NODE_ENV === 'test') && activePinia && activePinia._testing ? null : pinia) ||\r\n                (currentInstance && inject(piniaSymbol));\r\n        if (pinia)\r\n            setActivePinia(pinia);\r\n        if ((process.env.NODE_ENV !== 'production') && !activePinia) {\r\n            throw new Error(`[\uD83C\uDF4D]: getActivePinia was called with no active Pinia. Did you forget to install pinia?\\n\\n` +\r\n                `const pinia = createPinia()\\n` +\r\n                `app.use(pinia)\\n\\n` +\r\n                `This will fail in production.`);\r\n        }\r\n        pinia = activePinia;\r\n        if (!pinia._s.has(id)) {\r\n            // creating the store registers it in `pinia._s`\r\n            if (isSetupStore) {\r\n                createSetupStore(id, setup, options, pinia);\r\n            }\r\n            else {\r\n                createOptionsStore(id, options, pinia);\r\n            }\r\n            /* istanbul ignore else */\r\n            if ((process.env.NODE_ENV !== 'production')) {\r\n                // @ts-expect-error: not the right inferred type\r\n                useStore._pinia = pinia;\r\n            }\r\n        }\r\n        const store = pinia._s.get(id);\r\n        if ((process.env.NODE_ENV !== 'production') && hot) {\r\n            const hotId = '__hot:' + id;\r\n            const newStore = isSetupStore\r\n                ? createSetupStore(hotId, setup, options, pinia, true)\r\n                : createOptionsStore(hotId, assign({}, options), pinia, true);\r\n            hot._hotUpdate(newStore);\r\n            // cleanup the state properties and the store from the cache\r\n            delete pinia.state.value[hotId];\r\n            pinia._s.delete(hotId);\r\n        }\r\n        // save stores in instances to access them devtools\r\n        if ((process.env.NODE_ENV !== 'production') &&\r\n            IS_CLIENT &&\r\n            currentInstance &&\r\n            currentInstance.proxy &&\r\n            // avoid adding stores that are just built for hot module replacement\r\n            !hot) {\r\n            const vm = currentInstance.proxy;\r\n            const cache = '_pStores' in vm ? vm._pStores : (vm._pStores = {});\r\n            cache[id] = store;\r\n        }\r\n        // StoreGeneric cannot be casted towards Store\r\n        return store;\r\n    }\r\n    useStore.$id = id;\r\n    return useStore;\r\n}\n\nlet mapStoreSuffix = 'Store';\r\n/**\r\n * Changes the suffix added by `mapStores()`. Can be set to an empty string.\r\n * Defaults to `\"Store\"`. Make sure to extend the MapStoresCustomization\r\n * interface if you need are using TypeScript.\r\n *\r\n * @param suffix - new suffix\r\n */\r\nfunction setMapStoreSuffix(suffix // could be 'Store' but that would be annoying for JS\r\n) {\r\n    mapStoreSuffix = suffix;\r\n}\r\n/**\r\n * Allows using stores without the composition API (`setup()`) by generating an\r\n * object to be spread in the `computed` field of a component. It accepts a list\r\n * of store definitions.\r\n *\r\n * @example\r\n * ```js\r\n * export default {\r\n *   computed: {\r\n *     // other computed properties\r\n *     ...mapStores(useUserStore, useCartStore)\r\n *   },\r\n *\r\n *   created() {\r\n *     this.userStore // store with id \"user\"\r\n *     this.cartStore // store with id \"cart\"\r\n *   }\r\n * }\r\n * ```\r\n *\r\n * @param stores - list of stores to map to an object\r\n */\r\nfunction mapStores(...stores) {\r\n    if ((process.env.NODE_ENV !== 'production') && Array.isArray(stores[0])) {\r\n        console.warn(`[\uD83C\uDF4D]: Directly pass all stores to \"mapStores()\" without putting them in an array:\\n` +\r\n            `Replace\\n` +\r\n            `\\tmapStores([useAuthStore, useCartStore])\\n` +\r\n            `with\\n` +\r\n            `\\tmapStores(useAuthStore, useCartStore)\\n` +\r\n            `This will fail in production if not fixed.`);\r\n        stores = stores[0];\r\n    }\r\n    return stores.reduce((reduced, useStore) => {\r\n        // @ts-expect-error: $id is added by defineStore\r\n        reduced[useStore.$id + mapStoreSuffix] = function () {\r\n            return useStore(this.$pinia);\r\n        };\r\n        return reduced;\r\n    }, {});\r\n}\r\n/**\r\n * Allows using state and getters from one store without using the composition\r\n * API (`setup()`) by generating an object to be spread in the `computed` field\r\n * of a component.\r\n *\r\n * @param useStore - store to map from\r\n * @param keysOrMapper - array or object\r\n */\r\nfunction mapState(useStore, keysOrMapper) {\r\n    return Array.isArray(keysOrMapper)\r\n        ? keysOrMapper.reduce((reduced, key) => {\r\n            reduced[key] = function () {\r\n                return useStore(this.$pinia)[key];\r\n            };\r\n            return reduced;\r\n        }, {})\r\n        : Object.keys(keysOrMapper).reduce((reduced, key) => {\r\n            // @ts-expect-error\r\n            reduced[key] = function () {\r\n                const store = useStore(this.$pinia);\r\n                const storeKey = keysOrMapper[key];\r\n                // for some reason TS is unable to infer the type of storeKey to be a\r\n                // function\r\n                return typeof storeKey === 'function'\r\n                    ? storeKey.call(this, store)\r\n                    : store[storeKey];\r\n            };\r\n            return reduced;\r\n        }, {});\r\n}\r\n/**\r\n * Alias for `mapState()`. You should use `mapState()` instead.\r\n * @deprecated use `mapState()` instead.\r\n */\r\nconst mapGetters = mapState;\r\n/**\r\n * Allows directly using actions from your store without using the composition\r\n * API (`setup()`) by generating an object to be spread in the `methods` field\r\n * of a component.\r\n *\r\n * @param useStore - store to map from\r\n * @param keysOrMapper - array or object\r\n */\r\nfunction mapActions(useStore, keysOrMapper) {\r\n    return Array.isArray(keysOrMapper)\r\n        ? keysOrMapper.reduce((reduced, key) => {\r\n            // @ts-expect-error\r\n            reduced[key] = function (...args) {\r\n                return useStore(this.$pinia)[key](...args);\r\n            };\r\n            return reduced;\r\n        }, {})\r\n        : Object.keys(keysOrMapper).reduce((reduced, key) => {\r\n            // @ts-expect-error\r\n            reduced[key] = function (...args) {\r\n                return useStore(this.$pinia)[keysOrMapper[key]](...args);\r\n            };\r\n            return reduced;\r\n        }, {});\r\n}\r\n/**\r\n * Allows using state and getters from one store without using the composition\r\n * API (`setup()`) by generating an object to be spread in the `computed` field\r\n * of a component.\r\n *\r\n * @param useStore - store to map from\r\n * @param keysOrMapper - array or object\r\n */\r\nfunction mapWritableState(useStore, keysOrMapper) {\r\n    return Array.isArray(keysOrMapper)\r\n        ? keysOrMapper.reduce((reduced, key) => {\r\n            // @ts-ignore\r\n            reduced[key] = {\r\n                get() {\r\n                    return useStore(this.$pinia)[key];\r\n                },\r\n                set(value) {\r\n                    // it's easier to type it here as any\r\n                    return (useStore(this.$pinia)[key] = value);\r\n                },\r\n            };\r\n            return reduced;\r\n        }, {})\r\n        : Object.keys(keysOrMapper).reduce((reduced, key) => {\r\n            // @ts-ignore\r\n            reduced[key] = {\r\n                get() {\r\n                    return useStore(this.$pinia)[keysOrMapper[key]];\r\n                },\r\n                set(value) {\r\n                    // it's easier to type it here as any\r\n                    return (useStore(this.$pinia)[keysOrMapper[key]] = value);\r\n                },\r\n            };\r\n            return reduced;\r\n        }, {});\r\n}\n\n/**\r\n * Creates an object of references with all the state, getters, and plugin-added\r\n * state properties of the store. Similar to `toRefs()` but specifically\r\n * designed for Pinia stores so methods and non reactive properties are\r\n * completely ignored.\r\n *\r\n * @param store - store to extract the refs from\r\n */\r\nfunction storeToRefs(store) {\r\n    store = toRaw(store);\r\n    const refs = {};\r\n    for (const key in store) {\r\n        const value = store[key];\r\n        if (isRef(value) || isReactive(value)) {\r\n            // @ts-expect-error: the key is state or getter\r\n            refs[key] =\r\n                // ---\r\n                toRef(store, key);\r\n        }\r\n    }\r\n    return refs;\r\n}\n\n/**\r\n * Vue 2 Plugin that must be installed for pinia to work. Note **you don't need\r\n * this plugin if you are using Nuxt.js**. Use the `buildModule` instead:\r\n * https://pinia.esm.dev/ssr/nuxt.html.\r\n *\r\n * @example\r\n * ```js\r\n * import Vue from 'vue'\r\n * import { PiniaVuePlugin, createPinia } from 'pinia'\r\n *\r\n * Vue.use(PiniaVuePlugin)\r\n * const pinia = createPinia()\r\n *\r\n * new Vue({\r\n *   el: '#app',\r\n *   // ...\r\n *   pinia,\r\n * })\r\n * ```\r\n *\r\n * @param _Vue\r\n */\r\nconst PiniaVuePlugin = function (_Vue) {\r\n    // Equivalent of\r\n    // app.config.globalProperties.$pinia = pinia\r\n    _Vue.mixin({\r\n        beforeCreate() {\r\n            const options = this.$options;\r\n            if (options.pinia) {\r\n                const pinia = options.pinia;\r\n                // HACK: taken from provide(): https://github.com/vuejs/composition-api/blob/master/src/apis/inject.ts#L30\r\n                /* istanbul ignore else */\r\n                if (!this._provided) {\r\n                    const provideCache = {};\r\n                    Object.defineProperty(this, '_provided', {\r\n                        get: () => provideCache,\r\n                        set: (v) => Object.assign(provideCache, v),\r\n                    });\r\n                }\r\n                this._provided[piniaSymbol] = pinia;\r\n                // propagate the pinia instance in an SSR friendly way\r\n                // avoid adding it to nuxt twice\r\n                /* istanbul ignore else */\r\n                if (!this.$pinia) {\r\n                    this.$pinia = pinia;\r\n                }\r\n                pinia._a = this;\r\n                if (IS_CLIENT) {\r\n                    // this allows calling useStore() outside of a component setup after\r\n                    // installing pinia's plugin\r\n                    setActivePinia(pinia);\r\n                    if ((process.env.NODE_ENV !== 'production')) {\r\n                        registerPiniaDevtools(pinia._a, pinia);\r\n                    }\r\n                }\r\n            }\r\n            else if (!this.$pinia && options.parent && options.parent.$pinia) {\r\n                this.$pinia = options.parent.$pinia;\r\n            }\r\n        },\r\n        destroyed() {\r\n            delete this._pStores;\r\n        },\r\n    });\r\n};\r\n/**\r\n * @deprecated use `PiniaVuePlugin` instead.\r\n */\r\nconst PiniaPlugin = PiniaVuePlugin;\n\nexport { MutationType, PiniaPlugin, PiniaVuePlugin, acceptHMRUpdate, createPinia, defineStore, getActivePinia, mapActions, mapGetters, mapState, mapStores, mapWritableState, setActivePinia, setMapStoreSuffix, storeToRefs };\n"],
  "mappings": "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",
  "names": []
}
